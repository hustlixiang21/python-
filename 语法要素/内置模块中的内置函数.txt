任务描述

我们在安装好了 Python 配置文件后，也将 Python 本身带有的库也安装好了， Python 自带的库也叫做 Python 的内置模块。

Python 的内置模块是 Python 编程的重要组织形式，内置模块中的内置函数也极大方便了编程过程中对函数等功能的使用。

本关的目标是让学习者了解并掌握 Python 内置模块和内置函数的相关知识。

相关知识

内置模块

 Python 中常见的内置模块如下：

os模块：文件和目录，用于提供系统级别的操作；
sys模块：用于提供对解释器相关的操作；
json模块：处理JSON字符串；
logging: 用于便捷记录日志且线程安全的模块；
time&datetime模块：时间相关的操作，时间有三种表示方式；
hashlib模块：用于加密相关操作，代替了md5模块，主要是提供SHA1、SHA224、SHA256、SHA384、SHA512和MD5算法；
random模块：提供随机数。
内置模块中的内置函数

 Python 的内置模块中也有很多使用十分方便的内置函数。

dir()函数

针对不同的对象，dir()函数的机制稍有不同：

如果是模块对象，返回模块所有属性的名称；
如果是类型对象，返回类型对象的所有属性的名称，包含所有此类型基类的属性名称；
如果一般实例对象（非以上两类），返回所有实例属性的名称，实例对应的类名称，以及类的基类的属性名称；

dir()函数是一个排好序的字符串列表，其内容是一个模块里定义过的名字，包含在一个模块里定义的所有模块、变量和函数。例如：

# 导入内置math模块
import math
# 调用math模块中的dir()函数
content = dir(math)
# 输出math模块中所有模块、函数和变量的名字
print(content)
输出结果：

['__doc__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs','factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin','sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']
程序输出了math模块中所有模块、函数和变量的名字。特殊字符串变量__name__是指向模块的名字，变量__file__是指向该模块的导入文件名。

globals()和locals()函数

globals()和locals()函数可被用来返回全局和局部命名空间里的名字。

如果在函数内部调用的是globals()函数，那么返回的是所有在该函数里能够访问的全局名字。

如果在函数内部调用的locals()函数，返回的是能够在该函数里访问的局部命名。

globals()函数和locals()函数的返回类型都是字典，所以名字们能用keys()函数摘取。

来自csdn：

Python 内置函数 locals（） 和globals（）

1》这两个函数主要提供，基于字典的访问局部变量和全局变量的方式。
python 使用叫做名字空间的东西来记录变量的轨迹。名字空间是一个字典 ，它的键就是字符串形式的变量名字，它的值就是变量的实际值。
名字空间可以像 Python 的 dictionary 一样进行访问。
在一个 Python 程序中的任何一个地方，都存在几个可用的名字空间。
每个函数都有着自已的名字空间，叫做局部名字空间，它记录了函数的变量，包括函数的参数和局部定义的变量。
每个模块拥有它自已的名字空间，叫做全局名字空间，它记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
还有就是内置名字空间， 任何模块均可访问它，它存放着内置的函数和异常。
2》当一行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序:
局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x, 或一个参数 x，Python 将使用它，然后停止搜索。
全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用它然后停止搜索。
内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。
如果 Python 在这些名字空间找不到 x，它将放弃查找并引发一个 NameError 异常，
同时传递 There is no variable named 'x' 这样一条信息.
3》名字空间在运行时直接可以访问。局部名字空间可以通过内置的 locals 函数来访问。全局 (模块级别) 名字空间可以通过内置的 globals 函数来访问。
locals 对局部 (函数) 名字空间做了些什么，globals 就对全局 (模块) 名字空间做了什么。
然而 globals 更令人兴奋，因为一个模块的名字空间包含了模块级的变量和常量，它还包括了所有在模块中定义的函数和类，以及任何被导入到模块中的东西。
4》回想一下 from module import 和 import module 之间的不同？
使用 import module，模块自身被导入，但是它保持着自已的名字空间，
这就是为什么您需要使用模块名来访问它的函数或属性: module.function 的原因。
但是使用 from module import，实际上是从另一个模块中将指定的函数和属性导入到您自己的名字空间，
这就是为什么您可以直接访问它们却不需要引用它们所来源的模块的原因。
使用 globals 函数，您会真切地看到这一切的发生。
5》locals 是只读的,不可修改， 而globals可以修改，原因是：
locals（）实际上没有返回局部名字空间，它返回的是一个拷贝。所以对它进行修改，修改的是拷贝，而对实际的局部名字空间中的变量值并无影响。
globals（）返回的是实际的全局名字空间，而不是一个拷贝: 与 locals 的行为完全相反。
所以对 globals 所返回的 dictionary 的任何的改动都会直接影响到全局变量的取值。


reload()函数

当一个模块被导入到一个脚本中后，程序只会将模块顶层部分的代码执行一次。

因此，如果我们想再次执行模块顶层部分的代码，可以用reload()函数。

该函数便会重新将之前导入过的模块导入。格式如下：

reload(module_name)

在这里，module_name要直接放模块名，而不能是一个字符串形式。例如，我们想重载hello模块：

reload(hello)

reload()函数将以前导入过的模块再加载一次。重新加载（reload）包括最初导入模块时应用的分析过程和初始化过程。这样就允许在不退出解释器的情况下重新加载已更改的Python模块。 

若干注意事项： 
1. 如果模块在语法上是正确的，但在初始化过程中失败，则导入过程不能正确地将模块的名字绑定到符号表中。这时，必须在模块能被重新加载之前使用import()函数加载该模块。 
2. 重新加载的模块不删除最初旧版本模块在符号表中的登记项。 
3. 如果一模块利用from。。。import。。。方式从另一模块导入对象，reload（）函数不重新定义导入的对象，可利用import。。。形式避免这个问题。 
4. 提供类的重新加载模块不影响所提供类的任何已存实例---已存实例将继续使用原来的方法定义，只有该类的新实例使用新格式。这个原则对派生类同样适用。



在python中，每一个以 .py结尾的Python文件都是一个模块。其他的文件可以通过导入一个模块来读取该模块的内容。

导入从本质上来讲，就是载入另一个文件，并能够读取那个文件的内容。一个模块的内容通过这样的属性能够被外部世界使用。

这种基于模块的方式使模块变成了Python程序架构的一个核心概念。

更大的程序往往以多个模块文件的形式出现，并且导入了其他模块文件的工具。

其中的一个模块文件被设计成主文件，或叫做顶层文件（就是那个启动后能够运行整个程序的文件）。

默认情况下，模块在第一次被导入之后，其他的导入都不再有效。

如果此时在另一个窗口中改变并保存了模块的源代码文件，也无法更新该模块。

这样设计的原因在于，导入是一个开销很大的操作（导入必须找到文件，将其编译成字节码，并且运行代码），以至于每个文件、每个程序运行不能够重复多于一次。

那么想要使得Python在同一次会话中再次运行文件，该怎么办呢？

这就需要调用imp标准库模块中的reload函数。如下所示

from  imp import reload reload(MyModule)

这样就可以重新装载MyModule模块，使得修改有效。

注意：reload函数希望获得的参数是一个已经加载了的模块对象的名称，所以如果在重载之前,请确保已经成功地导入了这个模块。

说明：Python 3.0把reload内置函数移到了imp标准库模块中。它仍然像以前一样重载文件，但是，必须导入它才能使用。

在Python 3.0中，运行import imp并使用imp.reload(M)，或者像上面所示的，运行from imp import并使用reload(M)

在python2中，reload()是内置函数，能够直接使用。

但是在python3中，直接使用reload()会报错，需要从imp中导入。用法为
[html]  view plain  copy   
>>>from imp import reload  
>>>reload(xyz)  


小结

Python 中的内置模块和内置函数可以帮助程序员快速完成编程功能，使他们不必重复开发已存在的常用代码，

因此极大的提高了办事效率和代码质量。Python 中的内置模块和内置函数的应用也十分广泛，

希望学习者在接下来的学习生活中有更加深刻的体会。

